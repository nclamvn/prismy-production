import {
  Document,
  Packer,
  Paragraph,
  TextRun,
  HeadingLevel,
  AlignmentType,
} from 'docx'
import jsPDF from 'jspdf'

interface ExportData {
  originalText: string
  translatedText: string
  sourceLanguage: string
  targetLanguage: string
  timestamp: Date
  qualityScore?: number
  processingTime?: number
}

// Format timestamp for consistent display
const formatTimestamp = (date: Date): string => {
  return date.toLocaleString('en-US', {
    year: 'numeric',
    month: 'long',
    day: 'numeric',
    hour: '2-digit',
    minute: '2-digit',
    timeZoneName: 'short',
  })
}

// Export as plain text with professional formatting
export const exportAsText = (
  data: ExportData,
  includeMetadata: boolean = true
): string => {
  const separator = '═'.repeat(80)
  const subSeparator = '─'.repeat(80)

  let content = ''

  // Header
  content += separator + '\n'
  content += 'TRANSLATION DOCUMENT\n'
  content += separator + '\n\n'

  // Metadata section
  if (includeMetadata) {
    content += 'DOCUMENT INFORMATION\n'
    content += subSeparator + '\n'
    content += `Translation Date: ${formatTimestamp(data.timestamp)}\n`
    content += `Source Language: ${data.sourceLanguage.toUpperCase()}\n`
    content += `Target Language: ${data.targetLanguage.toUpperCase()}\n`

    if (data.qualityScore) {
      content += `Quality Score: ${Math.round(data.qualityScore * 100)}%\n`
    }

    if (data.processingTime) {
      content += `Processing Time: ${(data.processingTime / 1000).toFixed(2)} seconds\n`
    }

    content += `Character Count (Original): ${data.originalText.length.toLocaleString()}\n`
    content += `Character Count (Translated): ${data.translatedText.length.toLocaleString()}\n`
    content += '\n'
  }

  // Original text section
  content += 'ORIGINAL TEXT\n'
  content += subSeparator + '\n'
  content += data.originalText + '\n\n'

  // Translated text section
  content += 'TRANSLATED TEXT\n'
  content += subSeparator + '\n'
  content += data.translatedText + '\n\n'

  // Footer
  content += separator + '\n'
  content += `Generated by Prismy Translation Services\n`
  content += `© ${new Date().getFullYear()} Prismy. All rights reserved.\n`

  return content
}

// Export as DOCX with professional formatting
export const exportAsDocx = async (
  data: ExportData,
  includeMetadata: boolean = true
): Promise<Blob> => {
  const sections = []

  // Title section
  sections.push(
    new Paragraph({
      text: 'TRANSLATION DOCUMENT',
      heading: HeadingLevel.TITLE,
      alignment: AlignmentType.CENTER,
      spacing: { after: 400 },
    })
  )

  // Metadata section
  if (includeMetadata) {
    sections.push(
      new Paragraph({
        text: 'Document Information',
        heading: HeadingLevel.HEADING_1,
        spacing: { before: 200, after: 200 },
      })
    )

    const metadataItems = [
      `Translation Date: ${formatTimestamp(data.timestamp)}`,
      `Source Language: ${data.sourceLanguage.toUpperCase()}`,
      `Target Language: ${data.targetLanguage.toUpperCase()}`,
    ]

    if (data.qualityScore) {
      metadataItems.push(
        `Quality Score: ${Math.round(data.qualityScore * 100)}%`
      )
    }

    if (data.processingTime) {
      metadataItems.push(
        `Processing Time: ${(data.processingTime / 1000).toFixed(2)} seconds`
      )
    }

    metadataItems.push(
      `Character Count (Original): ${data.originalText.length.toLocaleString()}`,
      `Character Count (Translated): ${data.translatedText.length.toLocaleString()}`
    )

    metadataItems.forEach(item => {
      sections.push(
        new Paragraph({
          children: [new TextRun({ text: item, size: 22 })],
          spacing: { after: 100 },
        })
      )
    })
  }

  // Original text section
  sections.push(
    new Paragraph({
      text: 'Original Text',
      heading: HeadingLevel.HEADING_1,
      spacing: { before: 400, after: 200 },
    })
  )

  // Split text by paragraphs and preserve formatting
  const originalParagraphs = data.originalText.split(/\n\n+/)
  originalParagraphs.forEach(para => {
    if (para.trim()) {
      sections.push(
        new Paragraph({
          children: [new TextRun({ text: para, size: 24 })],
          spacing: { after: 200 },
        })
      )
    }
  })

  // Translated text section
  sections.push(
    new Paragraph({
      text: 'Translated Text',
      heading: HeadingLevel.HEADING_1,
      spacing: { before: 400, after: 200 },
    })
  )

  const translatedParagraphs = data.translatedText.split(/\n\n+/)
  translatedParagraphs.forEach(para => {
    if (para.trim()) {
      sections.push(
        new Paragraph({
          children: [new TextRun({ text: para, size: 24 })],
          spacing: { after: 200 },
        })
      )
    }
  })

  // Footer
  sections.push(
    new Paragraph({
      children: [
        new TextRun({
          text: `Generated by Prismy Translation Services | © ${new Date().getFullYear()} Prismy`,
          size: 18,
          color: '666666',
        }),
      ],
      alignment: AlignmentType.CENTER,
      spacing: { before: 600 },
    })
  )

  const doc = new Document({
    sections: [
      {
        properties: {},
        children: sections,
      },
    ],
  })

  const buffer = await Packer.toBlob(doc)
  return buffer
}

// Export as JSON for developers/API integration
export const exportAsJson = (
  data: ExportData,
  includeMetadata: boolean = true
): string => {
  const jsonData: any = {
    translation: {
      original: data.originalText,
      translated: data.translatedText,
      sourceLanguage: data.sourceLanguage,
      targetLanguage: data.targetLanguage,
    },
  }

  if (includeMetadata) {
    jsonData.metadata = {
      timestamp: data.timestamp.toISOString(),
      timestampFormatted: formatTimestamp(data.timestamp),
      qualityScore: data.qualityScore,
      processingTime: data.processingTime,
      statistics: {
        originalLength: data.originalText.length,
        translatedLength: data.translatedText.length,
        originalWords: data.originalText.split(/\s+/).length,
        translatedWords: data.translatedText.split(/\s+/).length,
      },
    }

    jsonData.service = {
      provider: 'Prismy Translation Services',
      version: '1.0',
      copyright: `© ${new Date().getFullYear()} Prismy`,
    }
  }

  return JSON.stringify(jsonData, null, 2)
}

// Export as PDF with professional formatting
export const exportAsPdf = (
  data: ExportData,
  includeMetadata: boolean = true
): Blob => {
  const doc = new jsPDF()
  const pageWidth = doc.internal.pageSize.getWidth()
  const pageHeight = doc.internal.pageSize.getHeight()
  const margin = 25
  const lineHeight = 8
  const maxWidth = pageWidth - 2 * margin
  const columnWidth = (maxWidth - 15) / 2 // For two-column layout

  let yPosition = margin

  // Professional color scheme
  const primaryColor = [51, 107, 135] // Professional blue
  const secondaryColor = [100, 100, 100] // Gray
  const accentColor = [34, 197, 94] // Green for success

  // Helper function to add text with word wrapping
  const addWrappedText = (
    text: string,
    fontSize: number = 12,
    isBold: boolean = false,
    color: number[] = [0, 0, 0],
    maxTextWidth: number = maxWidth,
    xOffset: number = margin
  ) => {
    doc.setFontSize(fontSize)
    doc.setFont('helvetica', isBold ? 'bold' : 'normal')
    doc.setTextColor(color[0], color[1], color[2])

    const lines = doc.splitTextToSize(text, maxTextWidth)

    for (const line of lines) {
      if (yPosition > pageHeight - margin) {
        doc.addPage()
        addHeader() // Add header to new page
        yPosition = margin + 30
      }

      doc.text(line, xOffset, yPosition)
      yPosition += lineHeight
    }
  }

  // Helper function to add professional header
  const addHeader = () => {
    // Header background
    doc.setFillColor(primaryColor[0], primaryColor[1], primaryColor[2])
    doc.rect(0, 0, pageWidth, 25, 'F')

    // Header text
    doc.setTextColor(255, 255, 255)
    doc.setFontSize(14)
    doc.setFont('helvetica', 'bold')
    doc.text('PRISMY TRANSLATION SERVICES', margin, 16)

    // Reset colors
    doc.setTextColor(0, 0, 0)
  }

  // Helper function to add section box
  const addSectionBox = (
    title: string,
    bgColor: number[] = [248, 250, 252]
  ) => {
    // Section background
    doc.setFillColor(bgColor[0], bgColor[1], bgColor[2])
    doc.rect(margin - 5, yPosition - 5, maxWidth + 10, 20, 'F')

    // Section border
    doc.setDrawColor(primaryColor[0], primaryColor[1], primaryColor[2])
    doc.setLineWidth(0.5)
    doc.rect(margin - 5, yPosition - 5, maxWidth + 10, 20)

    // Section title
    doc.setTextColor(primaryColor[0], primaryColor[1], primaryColor[2])
    doc.setFontSize(14)
    doc.setFont('helvetica', 'bold')
    doc.text(title, margin, yPosition + 8)

    yPosition += 25
    doc.setTextColor(0, 0, 0)
  }

  // Helper function to add section separator
  const addSeparator = () => {
    yPosition += 10
    doc.setDrawColor(primaryColor[0], primaryColor[1], primaryColor[2])
    doc.setLineWidth(1)
    doc.line(margin, yPosition, pageWidth - margin, yPosition)
    yPosition += 15
  }

  // Add professional header
  addHeader()
  yPosition = margin + 35

  // Title with professional styling
  doc.setFillColor(248, 250, 252)
  doc.rect(margin - 10, yPosition - 10, maxWidth + 20, 30, 'F')
  doc.setDrawColor(primaryColor[0], primaryColor[1], primaryColor[2])
  doc.setLineWidth(2)
  doc.rect(margin - 10, yPosition - 10, maxWidth + 20, 30)

  doc.setTextColor(primaryColor[0], primaryColor[1], primaryColor[2])
  doc.setFontSize(24)
  doc.setFont('helvetica', 'bold')
  const title = 'TRANSLATION DOCUMENT'
  const titleWidth = doc.getTextWidth(title)
  doc.text(title, (pageWidth - titleWidth) / 2, yPosition + 8)
  yPosition += 40

  doc.setTextColor(0, 0, 0)

  // Metadata section with professional styling
  if (includeMetadata) {
    addSectionBox('DOCUMENT INFORMATION', [240, 248, 255])

    const metadataItems = [
      `Translation Date: ${formatTimestamp(data.timestamp)}`,
      `Source Language: ${data.sourceLanguage.toUpperCase()}`,
      `Target Language: ${data.targetLanguage.toUpperCase()}`,
    ]

    if (data.qualityScore) {
      metadataItems.push(
        `Quality Score: ${Math.round(data.qualityScore * 100)}%`
      )
    }

    if (data.processingTime) {
      metadataItems.push(
        `Processing Time: ${(data.processingTime / 1000).toFixed(2)} seconds`
      )
    }

    metadataItems.push(
      `Character Count (Original): ${data.originalText.length.toLocaleString()}`,
      `Character Count (Translated): ${data.translatedText.length.toLocaleString()}`
    )

    metadataItems.forEach(item => {
      addWrappedText(item, 12, false, secondaryColor)
      yPosition += 2
    })

    yPosition += 15
  }

  // Two-column layout for side-by-side comparison
  const startY = yPosition

  // Original text column (left)
  addSectionBox('ORIGINAL TEXT', [255, 245, 245])
  const originalStartY = yPosition
  addWrappedText(data.originalText, 11, false, [0, 0, 0], columnWidth, margin)
  const originalEndY = yPosition

  // Reset position for translated column
  yPosition = originalStartY

  // Translated text column (right)
  const rightColumnX = margin + columnWidth + 15
  doc.setFillColor(245, 255, 245)
  doc.rect(rightColumnX - 5, originalStartY - 25, columnWidth + 10, 20, 'F')
  doc.setDrawColor(accentColor[0], accentColor[1], accentColor[2])
  doc.setLineWidth(0.5)
  doc.rect(rightColumnX - 5, originalStartY - 25, columnWidth + 10, 20)

  doc.setTextColor(accentColor[0], accentColor[1], accentColor[2])
  doc.setFontSize(14)
  doc.setFont('helvetica', 'bold')
  doc.text('TRANSLATED TEXT', rightColumnX, originalStartY - 12)

  doc.setTextColor(0, 0, 0)
  addWrappedText(
    data.translatedText,
    11,
    false,
    [0, 0, 0],
    columnWidth,
    rightColumnX
  )
  const translatedEndY = yPosition

  // Set position to the maximum of both columns
  yPosition = Math.max(originalEndY, translatedEndY) + 20

  // Professional footer with branding
  const footerY = pageHeight - 20

  // Footer background
  doc.setFillColor(248, 250, 252)
  doc.rect(0, footerY - 10, pageWidth, 20, 'F')

  // Footer border
  doc.setDrawColor(primaryColor[0], primaryColor[1], primaryColor[2])
  doc.setLineWidth(0.5)
  doc.line(0, footerY - 10, pageWidth, footerY - 10)

  // Footer text
  const footerText = `Generated by Prismy Translation Services | © ${new Date().getFullYear()} Prismy | www.prismy.in`
  doc.setFontSize(10)
  doc.setFont('helvetica', 'normal')
  doc.setTextColor(secondaryColor[0], secondaryColor[1], secondaryColor[2])

  const footerWidth = doc.getTextWidth(footerText)
  doc.text(footerText, (pageWidth - footerWidth) / 2, footerY)

  // Add page numbers
  const pageCount = doc.getNumberOfPages()
  for (let i = 1; i <= pageCount; i++) {
    doc.setPage(i)
    doc.setFontSize(10)
    doc.setTextColor(secondaryColor[0], secondaryColor[1], secondaryColor[2])
    doc.text(`Page ${i} of ${pageCount}`, pageWidth - margin, footerY)
  }

  return doc.output('blob')
}

// Helper function to trigger download
export const downloadFile = (
  content: string | Blob,
  filename: string,
  mimeType: string
) => {
  const blob =
    content instanceof Blob ? content : new Blob([content], { type: mimeType })
  const url = window.URL.createObjectURL(blob)
  const link = document.createElement('a')

  link.href = url
  link.download = filename
  document.body.appendChild(link)
  link.click()

  // Cleanup
  document.body.removeChild(link)
  window.URL.revokeObjectURL(url)
}

// Generate filename with timestamp
export const generateFilename = (
  baseType: string,
  sourceLang: string,
  targetLang: string,
  extension: string
): string => {
  const timestamp = new Date().toISOString().replace(/[:.]/g, '-').slice(0, -5)
  return `${baseType}_${sourceLang}_to_${targetLang}_${timestamp}.${extension}`
}
